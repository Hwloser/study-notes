# hdfs租约解析

租约（lease）是一种广泛应用于分布式系统领域的协议，主要用来维护分布式系统的一致性。

租约i在解决缓存一致性时被提出的。所谓租约，其实就是一个 合同，即服务器基于客户端在一定期限内可以控制修改操作的权限。如果服务器要修改数据，首先要征求拥有这块数据的租约的客户端的同意，之后才可以修改。客户端从服务器读取数据时往往就同时获取租约，在租约期限内，如果收到服务器的修改请求，就可以保证当前缓存中的内容就是最新的。如果在租约期限内收到了修改数据的请求并且同意了，就需要清空缓存。在租约过期之后，客户端如果还要从缓存读取数据，就必须重新获取租约，我们称这个操作为续约。

## 租约特性

租约的一个重要的数据就是**期限**，一般情况下应当选择较短的租约期限。与长租约相比较，短租约有三个有点。

首先，在失效情况下修改操作往往需要等待租约过期，因此短租约就意味着更短的时间延迟。其次，就算一个客户端已经不再需要读取数据，但在其租约过期之前，任何修改操作任然需要征求它的同意，这种情况叫做 “假共享”，显然租约期越长，这个问题就越严重。最后，短租约也是的服务器要维护的客户端信息更少。然而短租约也意味着更大的续约开销，因此对于要反复读取却很少修改的数据，长租约会更有效。因此，对于租期的选择要权衡失效延迟、假共享开销和续约开销等多个因素，服务器可以根据数据访问特性和客户端的性质灵活设置期限。事实上，如果我们把租约起线设为零，就相当于轮询，此时修改操作随时可以进行，而读取数据总是要联系服务器。如果把租约起线设置为无限长，就相当于回调。

除了期限的选择，还有很多管理选项。对于客户端来说，可以选择是否续约、何时续约以及是否同意修改等。比如为了减少读取延迟，客户端可以在租约过期前就续约，不过这样可能夹中服务器的负担。对服务器来说，可以选择是否发方租约、租约覆盖粒度以及对如何进行修改等操作。比如在收到修改请求后，服务器可以不征求客户端同意，而是简单的等待所有的租约过期（等待时不再发方新租约以避免无限期的延迟）。对于“安装文件”，也就是修改极少的文件（比如头文件、库文件），服务器可以用一个租约来覆盖一批文件，同时定期广播续约通知来节省开销，如果需要修改数据，就停止广播并等待租约过期即可。

在很多时候，租约的定义似乎很模糊，有的时候租约类似*心跳*，有的时候又类似于*锁(读锁和写锁)*。到底租约的本质是什么呢？

回到租约最原始的定义：**租约就是在一定期限内基于持有者特定的权限。**我觉得这里的起线就是租约的根本特性，正式这一特性使得租约可以容忍机器失效和网络分割。在期限之内，租约其实就是服务器和客户端之间的协议，而这个协议的内容可以五花八门。*如果协议内容是服务器确认客户端还存活，那么这个租约的功能就相当于心跳*；*如果协议内容是服务器保证内容不会被修改，那么这个租约就相当于读锁*；*如果协议内容是服务器保证内容只能被这个客户端修改，那么这个租约就相当于写锁*。租约这种灵活性和容错性，使其成为了维护分布式系统一致性的有效工具。

## 租约在HDFS中的应用–写锁

hdfs支持write-once-read-many，也就是说不支持并行写，那么对读写的互斥同步就是靠Lease实现的。Lease说白了就是一个有时间约束的锁。客户端写文件时需要先申请一个Lease，持有该租约的客户端才可以对相应的文件进行块的添加。

与租约相关的类有：

```
Server端：
LeaseManager – 管理写文件相关的租约
LeaseManager.Monitor – 监控租约是否过期(主要检查hardLimit)
LeaseManager.Lease – 租约实体类，管理某个客户端持有的所以写锁
```

Client端：

```
LeaseRenewer – 客户端续约更新类
```

```java
class Lease implements Comparable<Lease> {
  // 租约持有者(持有租约的客户端名字)
  private final String holder;
  // 租约更新的时间
  private long lastUpdate;
  // 该租约中包含的文件(包含持有该租约的客户端所打开的所有文件)
  private final Collection<String> paths = new TreeSet<String>();
}
```

一个客户端对应一个租约，一个客户端可以同时写很多个文件，这些文件放在`paths`中，租约维护着这些文件的写权限，并对这些文件统一续约，并不是对某个文件单独续约，不需要对某个文件进行操作之后直接从`paths`中移除，如果`paths`为null，则回收此租约。
