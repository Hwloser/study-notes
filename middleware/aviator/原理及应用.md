# 原理及应用

Aviator的基本过程是将表达式直接翻译成对应的java字节码执行，郑国过程最多扫两趟（开启执行优先模式，如果是编译优先模式下扫描一趟）。

Aviator除了以来`commons-beanutils`（用于reflect）之外不依赖于任何的第三方库，整体非常的轻量级。

Aviator的内置函数非常 "节制"，除了必须的字符串处理、数学函数和集合处理之外，类似文件、网络IO均无法使用，这样能保证运行期的安全。

> 如果需要实现这些高阶能力，可以通过开放的自定义函数来接入。

### <font color="green">特点</font>

- 高性能
- 轻量级
- **other feature：**
  - 支持运算符重载
  - 原生支持大整数和` BigDecimal `类型和运算，并且通过运算符重载和一般数字类型保持一致的运算方式。
  - 原生支持正则表达式类型以及匹配运算符`=~`
  - 类`  clojure `的` seq `库及` lambda `支持，可以灵活地处理各种集合
- 开放能力：包括自定义函数接入以及定制选项

## AviatorScript - 5.0

- 词法作用域`{...}`，和 let 定义作用域内的变量
- `return`语句，用于从函数或者`script`中返回（值）
- `if/elsif/else`条件语句
- `for/while`循环语句，以及`break/continue` 支持
- `fn`语法用于定义命名函数， 4.0 已经引入了`lambda -> ... end`语法专门用于匿名函数定义
- `## 单行注释 支持`
- 和`Java Scripting API`更好的集成
- 字符串插值
- 异常处理`try...catch...finally`语句等等。

**未改变特色：**

- 继续保持轻量化。
- 还是`two pass`，最终生成 JVM 字节码，保证性能比一般解释型脚本快。
- 函数继续“节制”，但是现在也有很灵活的方式来调用任何`Java`方法。
- 向前兼容，不兼容的地方很少，我们将在发布版本里说明。

