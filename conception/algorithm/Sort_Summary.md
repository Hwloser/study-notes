# 排序算法总结：

## 概括

* 比较算法：时间复杂度`O(nlogn)~O(n^2)`，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。
* 另一种是非比较排序，时间复杂度可以达到`O(n)`，主要有：计数排序，基数排序，桶排序等。


----------

排序方法|平均情况|最好情况|最坏情况|空间|稳定性
-|-|-|-|-|-
冒泡|O(n2)|O(n)|O(n2)|O(1)|稳定
简单选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定
直接插入排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定
希尔排序|O(nlogn) ~ O(n^2)|O(n^1.3)|O(n^2)|O(1)|不稳定
堆排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|不稳定
归并排序|O(nlogn)|O(nlogn)|O(nlogn)|O(n)|稳定
快速排序|O(nlogn)|O(nlogn)|O(n2)|O(logn)~O(n)|不稳定


----------
* 排序算法的稳定性问题：如果arr[i]=arr[j]，排序前arr[i]在arr[j]之前，排序后arr[i]还在arr[j]之前，则这种排序算法是稳定的。通俗地将就是保证排序前后两个数的相对顺序不变。

```
static void swap(int[] arr,int i,int j) {
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```

----------

## 冒泡排序：-》大的上浮

冒泡排序是比较简单的排序算法，它的运作过程如下：

* 进行`n-1`此排序
* 每次排序从`0~n-1-i`(`i`是次数编号)检查这个序列中的数，两两相邻的数，如果前面的大于后面的就将他们交换，这样使得大的数往后面走，每次冒泡就会将一个大的数往后冒，从而达到目的。

## 鸡尾酒排序：-》左右指针法

定向冒泡排序：

* 它的改进在于同时的冒泡两边，从低到高，然后从高到低；
* 相当于顺便把最小的数呀冒泡到最前面这个方法比冒泡更加高效一点
```
static void check cocktailSort(int[] arr){
	int L = 0,R = arr.length-1;
	while(L<R){
		for(int i = L;;i++) if(arr[i+1]) swap(i,i+1);
		R--;
		for(int i =R;;i--) if(arr[i]<arr[i-1]) swap(i,i-1);
		L++;
	}
}
```

## 选择排序：搜索并入队列

* 在序列中找到最小(大)的元素，放到序列的起始位置作为已排序的序列；
* 在从剩余未排序元素中寻找最大(小)元素，放到已排序的末尾；

## 插入排序：-》单向链表

插入排序的思想有点类似抓扑克牌，

* 从第一个元素开始，该元素可以看作已经排序好的；
* 去除下一个元素，从这个元素从后往前开始扫描，如果该元素大于新元素，将该元素移到下一位置；
* 重复上述步骤，知道找到已排序的元素小于或等于新元素的位置，将新元素插入到该位置后；

## 二分插入排序：-》单向链表+二分查找

二分插入排序是对插入排序的一个小小的改进：

* 改进的地方在于前面已经排好序的序列中找到当前要插入的元素的时候采用二分查找的方式去找那个插入的位置(大于key的那个地方)；
* 找到那个位置之后，再进行元素的移动，以及把那个元素插入到找到的那个位置

## 希尔排序：-》分块(步长的选择)+链表

希尔排序是更高效的插入排序，它的思想在于，

* 把数组分成几块，每一块进行一个插入排序；
* 而分块的依据在于增量的选择分好快之后，从gap开始到n，每一组和前面的元素(自己组内的)进行插入排序；
* 每次和组内的元素比较完之后，最后的元素就是有序的了，希尔排序相对于插入排序的又是在于插入排序每次只能将数据移动一位，不过希尔排序时间复杂度的大小还是要取决于步长的和适度，另外希尔排序不是一种稳定的排序算法。
* 通过步长增量的选择，将数组无限的分下去直至x/increment=0得到排序完成的数组

## 快速排序

快速排序有几种不同的实现方式，

1. 左右指针法：
	1. 选取一个关键字(key)作为枢纽，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢纽。
	2. 设置两个变量为low=0和right=length-1
	3. 从left一直往后走，直到找到一个大于key的值，right从后至前，直至找到一个小于key的值，然后交换这两个数。
	4. 重复第三步，一直往后找，直到left和right相遇，这时将key放置left的位置即可。
	5. 再对左右两边的partition进行递归操作

2. 挖坑法
	1. 选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴，也是初始的坑位。
	2. 设置两个变量left = 0;right = N - 1;
	3. 从left一直向后走，直到找到一个大于key的值，然后将该数放入坑中，坑位变成了array[left]。
	4. right一直向前走，直到找到一个小于key的值，然后将该数放入坑中，坑位变成了array[right]。
	5. 重复3和4的步骤，直到left和right相遇，然后将key放入最后一个坑位。

3. 快慢指针法

## 归并排序

归并排序也是分治法的一个很好的应用，先递归到最底层，然后从下往上每次两个序列进行归并合起来，是一个由上往下分割，再由下往上合并的过程。

而对于每一次合并操作，对于每一次merge的操作过程如下：

* 准备一个额外的数组(help)，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
* 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
* 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
* 重复步骤3直到某一指针达到序列尾；
* 将另一序列剩下的所有元素直接复制到合并序列尾；

## 堆排序

堆排序的过程建立一个大根堆
