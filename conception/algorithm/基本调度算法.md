## 1. 先来先服务算法

先来先服务算法(FCFS)算法是一种常见的算法，它是人的本性中的一种公平观念。其优点就是简单且容易实现，缺点则是短作业可能变得变得很慢，因为其前面的长作业在执行，这样就会造成用户的交互式体验也比较差。

例如排队办理业务时，你要办理的业务只需要几分钟就可以办好，但是你前面的一个人办理的事情很复杂需要1个小时，这是你需要在他后面等很久，于是你就想到要是每个人轮流办理10分钟事务的话，那该多好！于是就出现了时间片轮转算法。

## 2. 时间片轮转算法

时间片轮转算法是对FCFS(先来先服务)算法的一种改进，其主要目的是改善端程序的响应时间，实现方式就是周期性地进行进程切换。时间片轮转的重点在于时间片的选择，需要考虑多方因素：如果运行的进程多时，时间片就需要短一些；进程数量少时，时间片就可以适当长一些，因此，时间片的选择是一个综合的考虑，权衡各方利益，进行适当折中。

但是，时间片轮转的系统响应时间也不一定总是比FCFS的响应时间段。时间片轮转是一种大锅饭的做法，但是显示生活中缺失走出的"一部分人先富，先富带动后富"的路线。例如，如果有30个任务，其中一个任务只需要1秒时间执行，而其他29个任务需要30秒 执行，如果因为某种原因，这个只需要1秒执行完的任务安排在另外29个任务的后面轮转，则它需要等待29秒才执行(假定时间片为1秒)。于是，这个任务的响应时间和交互体验就变得非常差。因此，段任务优先算法被提出。

## 3. 短任务优先算法

短任务优先算法的核心是所有的任务并不都一样，而是有优先级的区分。具体来说，就是短任务的优先级比长任务的高，而我们总是安排优先级高的任务先运行。

短任务优先算法又分为两种类型：一种是非抢占式的，另一种是抢占式的。非抢占式当已经cpu上运行的任务结束或阻塞时，从候选任务中选择执行时间最短的进程来执行。而抢占式则是每增加一个新的进程就需要对所有进程(包括正在cpu上运行的进程)进程检查，谁的时间短就运行谁。

由于短任务优先总是运行需要执行时间最短的程序，因此其系统平均响应时间在以上几种算法中时最优的，这也是短任务优先算法的优点。但短任务优先算法也有缺点：一是可能造成任务无法得到cpu时间从而导致"饥饿"；二是如何知道每个进程还需要运转多久？于是为了解决第一个缺点，优先级调度算法被提出。而第二个缺点则可以采取一些启发式的方式来进行估算，目前很多的人工智能算法都可以做这个事。

## 4. 优先级调度算法

优先级调度算法给每个进程赋予一个优先级，每次需要进程切换的时候，找一个优先级最高的进程进行调度。这样如果赋予长进程一个高优先级，则该进程就不会再"饥饿"。事实上，短任务优先算法本身就是一种优先级调度，只不过他给予段进程更高的优先级而已。

该算法的优点在于可以赋予重要的进程以高优先级确保重要任务能够得到cpu时间片，其缺点有二：一是低优先级的进程可能会"饥饿"，二是响应时间无法得到保证。第一个缺点可以通过动态地调节任务的优先级解决，例如一个进程如果等待时间过长，其优先级将因此持续提升而超越其他进程的优先级，从而得到cpu时间片。第二个缺点可以通过将一个进程优先级设置为最高来解决。但即使将优先级设置为最高来解决，但即使将优先级设置为最高，但如果每个人都将自己的进程优先级设置为最高，其响应时间还是无法得到保证。

## 5. 混合调度算法

之前的算法都存在一定的缺点，那么可否有一个算法混合他们的优点，摒弃他们的缺点，这就是所谓的混合调度算法。混合调度算法将所有进程分为不同的大类，每个大类为一个优先级。如果两个进程处于不同的大类，则处于高优先级大类的进程优先执行；如果处于同一个大类，则采用时间片轮转算法来执行。